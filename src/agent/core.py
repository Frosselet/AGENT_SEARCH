"""
AI Agent Core - Orchestrates documentation lookup and code analysis
"""

import ast
import asyncio
import re
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum

# BAML imports (these will be generated from the .baml file)
try:
    from baml_client import b
    from baml_client.types import (
        CodeAnalysisResult, 
        PackageInfo, 
        EfficiencyComparison,
        DeprecationAnalysis,
        CodeRecommendation
    )
except ImportError:
    # Fallback for development - these would be generated by BAML
    @dataclass
    class CodeAnalysisResult:
        packages_detected: List[str]
        trigger_reasons: List[str]
        recommendations: List['CodeRecommendation']
        lambda_optimizations: List[str]
    
    @dataclass 
    class CodeRecommendation:
        type: str
        current_code: str
        suggested_code: str
        reason: str
        confidence_score: float

class TriggerType(Enum):
    PACKAGE_IMPORT = "package_import"
    METHOD_DEPRECATION = "method_deprecation"
    PERFORMANCE_OPTIMIZATION = "performance_optimization"
    LAMBDA_OPTIMIZATION = "lambda_optimization"
    CUSTOM_REPO_REFERENCE = "custom_repo_reference"

@dataclass
class TriggerResult:
    trigger_type: TriggerType
    confidence: float
    details: Dict[str, Any]

class DocumentationAgent:
    """
    Main agent that decides when to look up documentation and generates recommendations
    """
    
    def __init__(self):
        self.performance_packages = {
            'pandas': ['polars', 'dask'],
            'requests': ['httpx', 'aiohttp'],
            'beautifulsoup4': ['selectolax', 'lxml'],
            'json': ['orjson', 'ujson'],
            'urllib': ['httpx', 'requests']
        }
        
        self.lambda_problematic_packages = [
            'tensorflow', 'pytorch', 'opencv-python', 'matplotlib', 
            'scipy', 'scikit-learn', 'pandas'  # Large packages
        ]
        
        self.custom_repos = []  # Will be populated from config
        
    async def analyze_code(self, code: str, context: str = "") -> CodeAnalysisResult:
        """
        Main entry point - analyzes code and triggers documentation lookup
        """
        triggers = self._evaluate_triggers(code, context)
        
        if not triggers:
            return CodeAnalysisResult(
                packages_detected=[],
                trigger_reasons=[],
                recommendations=[],
                lambda_optimizations=[]
            )
        
        # Use BAML to get structured analysis
        try:
            analysis = await b.AnalyzeCodeForTriggers(code, context)
            return analysis
        except Exception as e:
            # Fallback analysis
            return self._fallback_analysis(code, triggers)
    
    def _evaluate_triggers(self, code: str, context: str) -> List[TriggerResult]:
        """
        Evaluate if documentation lookup should be triggered
        """
        triggers = []
        
        # Parse code to extract imports and method calls
        try:
            tree = ast.parse(code)
            imports = self._extract_imports(tree)
            method_calls = self._extract_method_calls(tree)
        except SyntaxError:
            # If code can't be parsed, use regex fallbacks
            imports = self._extract_imports_regex(code)
            method_calls = self._extract_method_calls_regex(code)
        
        # Trigger 1: Package Import Detection
        for pkg in imports:
            if pkg in self.performance_packages:
                triggers.append(TriggerResult(
                    TriggerType.PACKAGE_IMPORT,
                    0.8,
                    {'package': pkg, 'alternatives': self.performance_packages[pkg]}
                ))
            
            if pkg in self.lambda_problematic_packages:
                triggers.append(TriggerResult(
                    TriggerType.LAMBDA_OPTIMIZATION,
                    0.9,
                    {'package': pkg, 'reason': 'large_size'}
                ))
        
        # Trigger 2: AWS Lambda Context
        if 'lambda' in context.lower() or 'aws lambda' in context.lower():
            for pkg in imports:
                if pkg in self.lambda_problematic_packages:
                    triggers.append(TriggerResult(
                        TriggerType.LAMBDA_OPTIMIZATION,
                        0.95,
                        {'package': pkg, 'context': 'aws_lambda'}
                    ))
        
        # Trigger 3: Performance-critical patterns
        if any(pattern in code.lower() for pattern in ['read_csv', 'dataframe', 'large dataset']):
            for pkg in imports:
                if pkg == 'pandas':
                    triggers.append(TriggerResult(
                        TriggerType.PERFORMANCE_OPTIMIZATION,
                        0.85,
                        {'package': pkg, 'pattern': 'data_processing'}
                    ))
        
        # Trigger 4: HTTP requests
        if any(pattern in code for pattern in ['requests.get', 'requests.post', 'urllib.request']):
            triggers.append(TriggerResult(
                TriggerType.PERFORMANCE_OPTIMIZATION,
                0.7,
                {'pattern': 'http_requests', 'suggestion': 'consider httpx for async'}
            ))
        
        return triggers
    
    def _extract_imports(self, tree: ast.AST) -> List[str]:
        """Extract package names from AST"""
        imports = []
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.append(alias.name.split('.')[0])
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.append(node.module.split('.')[0])
        return imports
    
    def _extract_method_calls(self, tree: ast.AST) -> List[str]:
        """Extract method calls from AST"""
        calls = []
        for node in ast.walk(tree):
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Attribute):
                    calls.append(node.func.attr)
        return calls
    
    def _extract_imports_regex(self, code: str) -> List[str]:
        """Fallback regex-based import extraction"""
        import_pattern = r'(?:from\s+(\w+)|import\s+(\w+))'
        matches = re.findall(import_pattern, code)
        imports = []
        for match in matches:
            pkg = match[0] or match[1]
            if pkg:
                imports.append(pkg.split('.')[0])
        return imports
    
    def _extract_method_calls_regex(self, code: str) -> List[str]:
        """Fallback regex-based method call extraction"""
        method_pattern = r'\.(\w+)\('
        return re.findall(method_pattern, code)
    
    def _fallback_analysis(self, code: str, triggers: List[TriggerResult]) -> CodeAnalysisResult:
        """Fallback analysis when BAML is not available"""
        packages = self._extract_imports_regex(code)
        trigger_reasons = [f"{t.trigger_type.value}: {t.details}" for t in triggers]
        
        return CodeAnalysisResult(
            packages_detected=packages,
            trigger_reasons=trigger_reasons,
            recommendations=[],
            lambda_optimizations=[]
        )
    
    async def get_package_recommendations(self, packages: List[str], context: str) -> List[CodeRecommendation]:
        """
        Get recommendations for detected packages
        """
        recommendations = []
        
        for package in packages:
            try:
                # Check for efficiency alternatives
                efficiency = await b.ComparePackageEfficiency(package, context)
                
                # Check for deprecation issues  
                deprecation = await b.CheckDeprecation(package, "")
                
                # Generate recommendations based on analysis
                # This would use the BAML function with the collected data
                
            except Exception as e:
                # Fallback recommendation logic
                if package in self.performance_packages:
                    recommendations.append(CodeRecommendation(
                        type="package_upgrade",
                        current_code=f"import {package}",
                        suggested_code=f"import {self.performance_packages[package][0]}",
                        reason=f"Consider {self.performance_packages[package][0]} for better performance",
                        confidence_score=0.7
                    ))
        
        return recommendations