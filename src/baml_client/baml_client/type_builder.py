###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing

from baml_py.baml_py import ClassBuilder, EnumBuilder, EnumValueBuilder, FieldType
from baml_py.type_builder import (
    ClassPropertyBuilder,
    ClassPropertyViewer,
    EnumValueViewer,
)
from baml_py.type_builder import TypeBuilder as _TypeBuilder

from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["AgentDecision","AnalysisResults","ArchitectureDecision","BusinessLogic","ChatContext","ChatMessage","ChatResponse","CodeAnalysisResult","CodeRecommendation","ConflictResolution","CostEstimate","CustomRepoInfo","DataFlow","DeprecationAnalysis","EfficiencyComparison","ErrorHandling","FileContext","PackageAlternative","PackageInfo","PerformanceEstimate","PipelineAnalysisResult","PipelineFunction","PipelineStageAnalysis","Resume","SplitterAnalysis","TransformationRequest","TransformationResult","ValidationResult","WorkspaceContext",]
        ), enums=set(
          []
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)


    @property
    def AgentDecision(self) -> "AgentDecisionAst":
        return AgentDecisionAst(self)

    @property
    def AnalysisResults(self) -> "AnalysisResultsAst":
        return AnalysisResultsAst(self)

    @property
    def ArchitectureDecision(self) -> "ArchitectureDecisionAst":
        return ArchitectureDecisionAst(self)

    @property
    def BusinessLogic(self) -> "BusinessLogicAst":
        return BusinessLogicAst(self)

    @property
    def ChatContext(self) -> "ChatContextAst":
        return ChatContextAst(self)

    @property
    def ChatMessage(self) -> "ChatMessageAst":
        return ChatMessageAst(self)

    @property
    def ChatResponse(self) -> "ChatResponseAst":
        return ChatResponseAst(self)

    @property
    def CodeAnalysisResult(self) -> "CodeAnalysisResultAst":
        return CodeAnalysisResultAst(self)

    @property
    def CodeRecommendation(self) -> "CodeRecommendationAst":
        return CodeRecommendationAst(self)

    @property
    def ConflictResolution(self) -> "ConflictResolutionAst":
        return ConflictResolutionAst(self)

    @property
    def CostEstimate(self) -> "CostEstimateAst":
        return CostEstimateAst(self)

    @property
    def CustomRepoInfo(self) -> "CustomRepoInfoAst":
        return CustomRepoInfoAst(self)

    @property
    def DataFlow(self) -> "DataFlowAst":
        return DataFlowAst(self)

    @property
    def DeprecationAnalysis(self) -> "DeprecationAnalysisAst":
        return DeprecationAnalysisAst(self)

    @property
    def EfficiencyComparison(self) -> "EfficiencyComparisonAst":
        return EfficiencyComparisonAst(self)

    @property
    def ErrorHandling(self) -> "ErrorHandlingAst":
        return ErrorHandlingAst(self)

    @property
    def FileContext(self) -> "FileContextAst":
        return FileContextAst(self)

    @property
    def PackageAlternative(self) -> "PackageAlternativeAst":
        return PackageAlternativeAst(self)

    @property
    def PackageInfo(self) -> "PackageInfoAst":
        return PackageInfoAst(self)

    @property
    def PerformanceEstimate(self) -> "PerformanceEstimateAst":
        return PerformanceEstimateAst(self)

    @property
    def PipelineAnalysisResult(self) -> "PipelineAnalysisResultAst":
        return PipelineAnalysisResultAst(self)

    @property
    def PipelineFunction(self) -> "PipelineFunctionAst":
        return PipelineFunctionAst(self)

    @property
    def PipelineStageAnalysis(self) -> "PipelineStageAnalysisAst":
        return PipelineStageAnalysisAst(self)

    @property
    def Resume(self) -> "ResumeAst":
        return ResumeAst(self)

    @property
    def SplitterAnalysis(self) -> "SplitterAnalysisAst":
        return SplitterAnalysisAst(self)

    @property
    def TransformationRequest(self) -> "TransformationRequestAst":
        return TransformationRequestAst(self)

    @property
    def TransformationResult(self) -> "TransformationResultAst":
        return TransformationResultAst(self)

    @property
    def ValidationResult(self) -> "ValidationResultAst":
        return ValidationResultAst(self)

    @property
    def WorkspaceContext(self) -> "WorkspaceContextAst":
        return WorkspaceContextAst(self)





class AgentDecisionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AgentDecision")
        self._properties: set[str] = set([ "agent_name",  "decision",  "confidence",  "reasoning",  "outputs", ])
        self._props = AgentDecisionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AgentDecisionProperties":
        return self._props


class AgentDecisionViewer(AgentDecisionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class AgentDecisionProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def agent_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("agent_name"))

    @property
    def decision(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("decision"))

    @property
    def confidence(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("confidence"))

    @property
    def reasoning(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reasoning"))

    @property
    def outputs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("outputs"))



class AnalysisResultsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AnalysisResults")
        self._properties: set[str] = set([ "currentPattern",  "complexityScore",  "performanceImprovement",  "costSavings",  "awsServices",  "feasibility", ])
        self._props = AnalysisResultsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AnalysisResultsProperties":
        return self._props


class AnalysisResultsViewer(AnalysisResultsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class AnalysisResultsProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def currentPattern(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("currentPattern"))

    @property
    def complexityScore(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("complexityScore"))

    @property
    def performanceImprovement(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("performanceImprovement"))

    @property
    def costSavings(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("costSavings"))

    @property
    def awsServices(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("awsServices"))

    @property
    def feasibility(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("feasibility"))



class ArchitectureDecisionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ArchitectureDecision")
        self._properties: set[str] = set([ "primary_service",  "supporting_services",  "pattern",  "splitter_node",  "rationale",  "estimated_performance_improvement",  "estimated_cost_reduction",  "scalability",  "splitter_analysis", ])
        self._props = ArchitectureDecisionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ArchitectureDecisionProperties":
        return self._props


class ArchitectureDecisionViewer(ArchitectureDecisionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ArchitectureDecisionProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def primary_service(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("primary_service"))

    @property
    def supporting_services(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("supporting_services"))

    @property
    def pattern(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("pattern"))

    @property
    def splitter_node(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("splitter_node"))

    @property
    def rationale(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("rationale"))

    @property
    def estimated_performance_improvement(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("estimated_performance_improvement"))

    @property
    def estimated_cost_reduction(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("estimated_cost_reduction"))

    @property
    def scalability(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("scalability"))

    @property
    def splitter_analysis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("splitter_analysis"))



class BusinessLogicAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BusinessLogic")
        self._properties: set[str] = set([ "data_sources",  "transformations",  "outputs",  "business_rules",  "error_handling",  "configuration", ])
        self._props = BusinessLogicProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BusinessLogicProperties":
        return self._props


class BusinessLogicViewer(BusinessLogicAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class BusinessLogicProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def data_sources(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("data_sources"))

    @property
    def transformations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("transformations"))

    @property
    def outputs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("outputs"))

    @property
    def business_rules(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("business_rules"))

    @property
    def error_handling(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("error_handling"))

    @property
    def configuration(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("configuration"))



class ChatContextAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ChatContext")
        self._properties: set[str] = set([ "userMessage",  "conversationHistory",  "currentFileContext",  "workspaceContext", ])
        self._props = ChatContextProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChatContextProperties":
        return self._props


class ChatContextViewer(ChatContextAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ChatContextProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def userMessage(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("userMessage"))

    @property
    def conversationHistory(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("conversationHistory"))

    @property
    def currentFileContext(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("currentFileContext"))

    @property
    def workspaceContext(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("workspaceContext"))



class ChatMessageAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ChatMessage")
        self._properties: set[str] = set([ "type",  "content",  "timestamp", ])
        self._props = ChatMessageProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChatMessageProperties":
        return self._props


class ChatMessageViewer(ChatMessageAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ChatMessageProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def content(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("content"))

    @property
    def timestamp(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("timestamp"))



class ChatResponseAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ChatResponse")
        self._properties: set[str] = set([ "intent",  "confidence",  "content",  "suggestedActions",  "followUpQuestions",  "requiresFileAccess",  "recommendedCommands", ])
        self._props = ChatResponseProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChatResponseProperties":
        return self._props


class ChatResponseViewer(ChatResponseAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ChatResponseProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def intent(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("intent"))

    @property
    def confidence(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("confidence"))

    @property
    def content(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("content"))

    @property
    def suggestedActions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("suggestedActions"))

    @property
    def followUpQuestions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("followUpQuestions"))

    @property
    def requiresFileAccess(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("requiresFileAccess"))

    @property
    def recommendedCommands(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recommendedCommands"))



class CodeAnalysisResultAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CodeAnalysisResult")
        self._properties: set[str] = set([ "packages_detected",  "trigger_reasons",  "recommendations",  "lambda_optimizations", ])
        self._props = CodeAnalysisResultProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CodeAnalysisResultProperties":
        return self._props


class CodeAnalysisResultViewer(CodeAnalysisResultAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CodeAnalysisResultProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def packages_detected(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("packages_detected"))

    @property
    def trigger_reasons(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("trigger_reasons"))

    @property
    def recommendations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recommendations"))

    @property
    def lambda_optimizations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("lambda_optimizations"))



class CodeRecommendationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CodeRecommendation")
        self._properties: set[str] = set([ "type",  "current_code",  "suggested_code",  "reason",  "confidence_score", ])
        self._props = CodeRecommendationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CodeRecommendationProperties":
        return self._props


class CodeRecommendationViewer(CodeRecommendationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CodeRecommendationProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def current_code(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("current_code"))

    @property
    def suggested_code(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("suggested_code"))

    @property
    def reason(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reason"))

    @property
    def confidence_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("confidence_score"))



class ConflictResolutionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ConflictResolution")
        self._properties: set[str] = set([ "conflicting_agents",  "conflict_description",  "proposed_solutions",  "final_decision",  "confidence_score", ])
        self._props = ConflictResolutionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ConflictResolutionProperties":
        return self._props


class ConflictResolutionViewer(ConflictResolutionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ConflictResolutionProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def conflicting_agents(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("conflicting_agents"))

    @property
    def conflict_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("conflict_description"))

    @property
    def proposed_solutions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("proposed_solutions"))

    @property
    def final_decision(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("final_decision"))

    @property
    def confidence_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("confidence_score"))



class CostEstimateAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CostEstimate")
        self._properties: set[str] = set([ "reduction_percentage",  "monthly_savings_usd",  "cost_factors", ])
        self._props = CostEstimateProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CostEstimateProperties":
        return self._props


class CostEstimateViewer(CostEstimateAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CostEstimateProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def reduction_percentage(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reduction_percentage"))

    @property
    def monthly_savings_usd(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("monthly_savings_usd"))

    @property
    def cost_factors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("cost_factors"))



class CustomRepoInfoAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CustomRepoInfo")
        self._properties: set[str] = set([ "repo_name",  "functions_available",  "classes_available",  "latest_version",  "documentation_url", ])
        self._props = CustomRepoInfoProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CustomRepoInfoProperties":
        return self._props


class CustomRepoInfoViewer(CustomRepoInfoAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CustomRepoInfoProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def repo_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("repo_name"))

    @property
    def functions_available(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("functions_available"))

    @property
    def classes_available(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("classes_available"))

    @property
    def latest_version(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("latest_version"))

    @property
    def documentation_url(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("documentation_url"))



class DataFlowAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataFlow")
        self._properties: set[str] = set([ "type",  "target",  "source",  "line_number", ])
        self._props = DataFlowProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataFlowProperties":
        return self._props


class DataFlowViewer(DataFlowAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DataFlowProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def target(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("target"))

    @property
    def source(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("source"))

    @property
    def line_number(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("line_number"))



class DeprecationAnalysisAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DeprecationAnalysis")
        self._properties: set[str] = set([ "package_name",  "method_name",  "is_deprecated",  "deprecation_version",  "removal_version",  "alternatives",  "migration_notes", ])
        self._props = DeprecationAnalysisProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DeprecationAnalysisProperties":
        return self._props


class DeprecationAnalysisViewer(DeprecationAnalysisAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DeprecationAnalysisProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def package_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("package_name"))

    @property
    def method_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("method_name"))

    @property
    def is_deprecated(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("is_deprecated"))

    @property
    def deprecation_version(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("deprecation_version"))

    @property
    def removal_version(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("removal_version"))

    @property
    def alternatives(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("alternatives"))

    @property
    def migration_notes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("migration_notes"))



class EfficiencyComparisonAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EfficiencyComparison")
        self._properties: set[str] = set([ "package_name",  "alternatives",  "recommendation",  "performance_notes",  "lambda_compatibility", ])
        self._props = EfficiencyComparisonProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EfficiencyComparisonProperties":
        return self._props


class EfficiencyComparisonViewer(EfficiencyComparisonAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class EfficiencyComparisonProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def package_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("package_name"))

    @property
    def alternatives(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("alternatives"))

    @property
    def recommendation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recommendation"))

    @property
    def performance_notes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("performance_notes"))

    @property
    def lambda_compatibility(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("lambda_compatibility"))



class ErrorHandlingAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ErrorHandling")
        self._properties: set[str] = set([ "has_try_catch",  "exception_types",  "logging_present", ])
        self._props = ErrorHandlingProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ErrorHandlingProperties":
        return self._props


class ErrorHandlingViewer(ErrorHandlingAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ErrorHandlingProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def has_try_catch(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("has_try_catch"))

    @property
    def exception_types(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("exception_types"))

    @property
    def logging_present(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("logging_present"))



class FileContextAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FileContext")
        self._properties: set[str] = set([ "fileName",  "language",  "content",  "analysisResults", ])
        self._props = FileContextProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FileContextProperties":
        return self._props


class FileContextViewer(FileContextAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class FileContextProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def fileName(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("fileName"))

    @property
    def language(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("language"))

    @property
    def content(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("content"))

    @property
    def analysisResults(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("analysisResults"))



class PackageAlternativeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PackageAlternative")
        self._properties: set[str] = set([ "name",  "performance_score",  "lambda_size_mb",  "pros",  "cons",  "use_cases", ])
        self._props = PackageAlternativeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PackageAlternativeProperties":
        return self._props


class PackageAlternativeViewer(PackageAlternativeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PackageAlternativeProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def performance_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("performance_score"))

    @property
    def lambda_size_mb(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("lambda_size_mb"))

    @property
    def pros(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("pros"))

    @property
    def cons(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("cons"))

    @property
    def use_cases(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("use_cases"))



class PackageInfoAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PackageInfo")
        self._properties: set[str] = set([ "name",  "version",  "description",  "docs_url",  "repo_url",  "is_deprecated",  "deprecated_methods",  "alternative_packages", ])
        self._props = PackageInfoProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PackageInfoProperties":
        return self._props


class PackageInfoViewer(PackageInfoAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PackageInfoProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def version(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("version"))

    @property
    def description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("description"))

    @property
    def docs_url(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("docs_url"))

    @property
    def repo_url(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("repo_url"))

    @property
    def is_deprecated(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("is_deprecated"))

    @property
    def deprecated_methods(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("deprecated_methods"))

    @property
    def alternative_packages(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("alternative_packages"))



class PerformanceEstimateAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PerformanceEstimate")
        self._properties: set[str] = set([ "improvement_percentage",  "bottleneck_reduction",  "scalability_factor", ])
        self._props = PerformanceEstimateProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PerformanceEstimateProperties":
        return self._props


class PerformanceEstimateViewer(PerformanceEstimateAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PerformanceEstimateProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def improvement_percentage(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("improvement_percentage"))

    @property
    def bottleneck_reduction(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("bottleneck_reduction"))

    @property
    def scalability_factor(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("scalability_factor"))



class PipelineAnalysisResultAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PipelineAnalysisResult")
        self._properties: set[str] = set([ "current_pattern",  "functions_detected",  "complexity_score",  "migration_feasibility",  "estimated_effort_hours",  "aws_service_recommendations",  "business_logic",  "dependencies",  "data_flow", ])
        self._props = PipelineAnalysisResultProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PipelineAnalysisResultProperties":
        return self._props


class PipelineAnalysisResultViewer(PipelineAnalysisResultAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PipelineAnalysisResultProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def current_pattern(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("current_pattern"))

    @property
    def functions_detected(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("functions_detected"))

    @property
    def complexity_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("complexity_score"))

    @property
    def migration_feasibility(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("migration_feasibility"))

    @property
    def estimated_effort_hours(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("estimated_effort_hours"))

    @property
    def aws_service_recommendations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("aws_service_recommendations"))

    @property
    def business_logic(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("business_logic"))

    @property
    def dependencies(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("dependencies"))

    @property
    def data_flow(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("data_flow"))



class PipelineFunctionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PipelineFunction")
        self._properties: set[str] = set([ "name",  "line_count",  "arguments",  "has_async",  "has_decorators",  "decorators",  "calls_external_apis",  "file_operations",  "database_operations",  "data_transformations", ])
        self._props = PipelineFunctionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PipelineFunctionProperties":
        return self._props


class PipelineFunctionViewer(PipelineFunctionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PipelineFunctionProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def line_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("line_count"))

    @property
    def arguments(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("arguments"))

    @property
    def has_async(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("has_async"))

    @property
    def has_decorators(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("has_decorators"))

    @property
    def decorators(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("decorators"))

    @property
    def calls_external_apis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("calls_external_apis"))

    @property
    def file_operations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("file_operations"))

    @property
    def database_operations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("database_operations"))

    @property
    def data_transformations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("data_transformations"))



class PipelineStageAnalysisAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PipelineStageAnalysis")
        self._properties: set[str] = set([ "stage_name",  "complexity",  "runtime_estimate",  "parallelization_benefit",  "bottleneck_potential",  "split_justification", ])
        self._props = PipelineStageAnalysisProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PipelineStageAnalysisProperties":
        return self._props


class PipelineStageAnalysisViewer(PipelineStageAnalysisAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PipelineStageAnalysisProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def stage_name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stage_name"))

    @property
    def complexity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("complexity"))

    @property
    def runtime_estimate(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("runtime_estimate"))

    @property
    def parallelization_benefit(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("parallelization_benefit"))

    @property
    def bottleneck_potential(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("bottleneck_potential"))

    @property
    def split_justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("split_justification"))



class ResumeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Resume")
        self._properties: set[str] = set([ "name",  "email",  "experience",  "skills", ])
        self._props = ResumeProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResumeProperties":
        return self._props


class ResumeViewer(ResumeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResumeProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def email(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("email"))

    @property
    def experience(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("experience"))

    @property
    def skills(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("skills"))



class SplitterAnalysisAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SplitterAnalysis")
        self._properties: set[str] = set([ "optimal_split_point",  "split_rationale",  "pipeline_stages_analysis",  "performance_impact",  "cost_impact", ])
        self._props = SplitterAnalysisProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SplitterAnalysisProperties":
        return self._props


class SplitterAnalysisViewer(SplitterAnalysisAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SplitterAnalysisProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def optimal_split_point(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("optimal_split_point"))

    @property
    def split_rationale(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("split_rationale"))

    @property
    def pipeline_stages_analysis(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("pipeline_stages_analysis"))

    @property
    def performance_impact(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("performance_impact"))

    @property
    def cost_impact(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("cost_impact"))



class TransformationRequestAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TransformationRequest")
        self._properties: set[str] = set([ "pipeline_code",  "business_requirements",  "target_platform",  "performance_goals", ])
        self._props = TransformationRequestProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TransformationRequestProperties":
        return self._props


class TransformationRequestViewer(TransformationRequestAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class TransformationRequestProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def pipeline_code(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("pipeline_code"))

    @property
    def business_requirements(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("business_requirements"))

    @property
    def target_platform(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("target_platform"))

    @property
    def performance_goals(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("performance_goals"))



class TransformationResultAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TransformationResult")
        self._properties: set[str] = set([ "success",  "transformed_code",  "validation_results",  "infrastructure_code",  "git_workflow_results", ])
        self._props = TransformationResultProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TransformationResultProperties":
        return self._props


class TransformationResultViewer(TransformationResultAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class TransformationResultProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def success(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("success"))

    @property
    def transformed_code(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("transformed_code"))

    @property
    def validation_results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("validation_results"))

    @property
    def infrastructure_code(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("infrastructure_code"))

    @property
    def git_workflow_results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("git_workflow_results"))



class ValidationResultAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ValidationResult")
        self._properties: set[str] = set([ "functional_equivalence",  "performance_maintained",  "security_validated",  "test_coverage_adequate",  "issues_found", ])
        self._props = ValidationResultProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ValidationResultProperties":
        return self._props


class ValidationResultViewer(ValidationResultAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ValidationResultProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def functional_equivalence(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("functional_equivalence"))

    @property
    def performance_maintained(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("performance_maintained"))

    @property
    def security_validated(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("security_validated"))

    @property
    def test_coverage_adequate(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("test_coverage_adequate"))

    @property
    def issues_found(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("issues_found"))



class WorkspaceContextAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("WorkspaceContext")
        self._properties: set[str] = set([ "pythonFiles",  "recentAnalyses",  "projectType", ])
        self._props = WorkspaceContextProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "WorkspaceContextProperties":
        return self._props


class WorkspaceContextViewer(WorkspaceContextAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)


    def list_properties(self) -> list[tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class WorkspaceContextProperties:
    def __init__(self, bldr: ClassBuilder, properties: set[str]):
        self.__bldr = bldr
        self.__properties = properties



    @property
    def pythonFiles(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("pythonFiles"))

    @property
    def recentAnalyses(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recentAnalyses"))

    @property
    def projectType(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("projectType"))






__all__ = ["TypeBuilder"]
