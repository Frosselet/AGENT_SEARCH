###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import baml_py
from enum import Enum

from pydantic import BaseModel, ConfigDict

from typing_extensions import TypeAlias, Literal
from typing import Dict, Generic, List, Optional, TypeVar, Union


T = TypeVar('T')
CheckName = TypeVar('CheckName', bound=str)

class Check(BaseModel):
    name: str
    expression: str
    status: str
class Checked(BaseModel, Generic[T,CheckName]):
    value: T
    checks: Dict[CheckName, Check]

def get_checks(checks: Dict[CheckName, Check]) -> List[Check]:
    return list(checks.values())

def all_succeeded(checks: Dict[CheckName, Check]) -> bool:
    return all(check.status == "succeeded" for check in get_checks(checks))



class AgentDecision(BaseModel):
    agent_name: str
    decision: str
    confidence: float
    reasoning: str
    outputs: str

class AnalysisResults(BaseModel):
    currentPattern: str
    complexityScore: float
    performanceImprovement: str
    costSavings: str
    awsServices: List[str]
    feasibility: str

class ArchitectureDecision(BaseModel):
    primary_service: str
    supporting_services: List[str]
    pattern: str
    splitter_node: str
    rationale: str
    estimated_performance_improvement: str
    estimated_cost_reduction: str
    scalability: str
    splitter_analysis: "SplitterAnalysis"

class BusinessLogic(BaseModel):
    data_sources: List[str]
    transformations: List[str]
    outputs: List[str]
    business_rules: List[str]
    error_handling: "ErrorHandling"
    configuration: List[str]

class ChatContext(BaseModel):
    userMessage: str
    conversationHistory: List["ChatMessage"]
    currentFileContext: Optional["FileContext"] = None
    workspaceContext: "WorkspaceContext"

class ChatMessage(BaseModel):
    type: str
    content: str
    timestamp: str

class ChatResponse(BaseModel):
    intent: str
    confidence: float
    content: str
    suggestedActions: List[str]
    followUpQuestions: List[str]
    requiresFileAccess: bool
    recommendedCommands: List[str]

class CodeAnalysisResult(BaseModel):
    packages_detected: List[str]
    trigger_reasons: List[str]
    recommendations: List["CodeRecommendation"]
    lambda_optimizations: List[str]

class CodeRecommendation(BaseModel):
    type: str
    current_code: str
    suggested_code: str
    reason: str
    confidence_score: float

class ConflictResolution(BaseModel):
    conflicting_agents: List[str]
    conflict_description: str
    proposed_solutions: List[str]
    final_decision: str
    confidence_score: float

class CostEstimate(BaseModel):
    reduction_percentage: float
    monthly_savings_usd: float
    cost_factors: List[str]

class CustomRepoInfo(BaseModel):
    repo_name: str
    functions_available: List[str]
    classes_available: List[str]
    latest_version: str
    documentation_url: Optional[str] = None

class DataFlow(BaseModel):
    type: str
    target: str
    source: str
    line_number: int

class DeprecationAnalysis(BaseModel):
    package_name: str
    method_name: str
    is_deprecated: bool
    deprecation_version: Optional[str] = None
    removal_version: Optional[str] = None
    alternatives: List[str]
    migration_notes: List[str]

class EfficiencyComparison(BaseModel):
    package_name: str
    alternatives: List["PackageAlternative"]
    recommendation: str
    performance_notes: List[str]
    lambda_compatibility: bool

class ErrorHandling(BaseModel):
    has_try_catch: bool
    exception_types: List[str]
    logging_present: bool

class FileContext(BaseModel):
    fileName: str
    language: str
    content: str
    analysisResults: Optional["AnalysisResults"] = None

class PackageAlternative(BaseModel):
    name: str
    performance_score: float
    lambda_size_mb: float
    pros: List[str]
    cons: List[str]
    use_cases: List[str]

class PackageInfo(BaseModel):
    name: str
    version: str
    description: Optional[str] = None
    docs_url: Optional[str] = None
    repo_url: Optional[str] = None
    is_deprecated: bool
    deprecated_methods: List[str]
    alternative_packages: List[str]

class PerformanceEstimate(BaseModel):
    improvement_percentage: float
    bottleneck_reduction: str
    scalability_factor: float

class PipelineAnalysis(BaseModel):
    complexity_score: int
    current_pattern: str
    modernization_potential: str
    performance_improvement: int
    cost_savings: int
    estimated_effort: int
    issues: List["PipelineIssue"]
    recommendations: List["PipelineRecommendation"]
    splitting_opportunities: List["SplittingOpportunity"]

class PipelineAnalysisResult(BaseModel):
    current_pattern: str
    functions_detected: List["PipelineFunction"]
    complexity_score: float
    migration_feasibility: str
    estimated_effort_hours: int
    aws_service_recommendations: List[str]
    business_logic: "BusinessLogic"
    dependencies: List[str]
    data_flow: List["DataFlow"]

class PipelineFunction(BaseModel):
    name: str
    line_count: int
    arguments: List[str]
    has_async: bool
    has_decorators: bool
    decorators: List[str]
    calls_external_apis: bool
    file_operations: bool
    database_operations: bool
    data_transformations: bool

class PipelineIssue(BaseModel):
    description: str
    severity: str
    line_number: Optional[int] = None

class PipelineRecommendation(BaseModel):
    description: str
    impact: str
    effort: str

class PipelineStageAnalysis(BaseModel):
    stage_name: str
    complexity: str
    runtime_estimate: str
    parallelization_benefit: str
    bottleneck_potential: str
    split_justification: Optional[str] = None

class PipelineTransformation(BaseModel):
    modernized_code: str
    architecture_pattern: str
    improvements: List[str]
    deployment_notes: List[str]

class Resume(BaseModel):
    name: str
    email: str
    experience: List[str]
    skills: List[str]

class SplitterAnalysis(BaseModel):
    optimal_split_point: str
    split_rationale: str
    pipeline_stages_analysis: List["PipelineStageAnalysis"]
    performance_impact: "PerformanceEstimate"
    cost_impact: "CostEstimate"

class SplittingOpportunity(BaseModel):
    location: str
    reason: str
    benefit: str

class TransformationRequest(BaseModel):
    pipeline_code: str
    business_requirements: str
    target_platform: str
    performance_goals: str

class TransformationResult(BaseModel):
    success: bool
    transformed_code: str
    validation_results: str
    infrastructure_code: str
    git_workflow_results: str

class ValidationResult(BaseModel):
    functional_equivalence: bool
    performance_maintained: bool
    security_validated: bool
    test_coverage_adequate: bool
    issues_found: List[str]

class WorkspaceContext(BaseModel):
    pythonFiles: List[str]
    recentAnalyses: List["AnalysisResults"]
    projectType: Optional[str] = None
